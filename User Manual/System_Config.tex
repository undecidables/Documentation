\subsection{Graphical System Configuration Diagram}

\includegraphics[width=\linewidth]{System_Config.png}

\subsection{Description of the Equipment used as Illustrated on the Diagram}
\begin{itemize}
\item \textbf{Client - Raspberry PI:} Is a very small computer with a very low power consumption. The PI can handle quite a few input/ouput devices via the USB/HDMI/LAN/GPIO ports.
\item \textbf{Camera:} A device which will capture an image of the user that will want to authenicate via biometrics.
\item \textbf{Fingerprint scanner:} A device that will capture the fingerprint of the user which will be used for authentication.
\item \textbf{Keypad:} Will be used by users that will gain access to the building via the keycode.
\item \textbf{USB Hub:} This device will allow the system to connect more than one device via USB to the client as well as give power to the client.
\item \textbf{Pressure mat:} This device will allow the system to pick up that the user is ready to be authenticated (usually facial recognition) to gain access to the building.
\item \textbf{Electromagnet door lock:} Will keep the door locked until the client has succesfully authenticated the user.
\item \textbf{ Server:} Will be used for all the heavy computations such as facial/finger print recognition, etc.
\end{itemize}

\subsection{System Configuration Explained}
The system is made up of pluggable authentication devices such as a keypad, camera and fingerprint scanner, as well a client (Raspberry Pi) and a server. The entire authentication process is started a soon as the user steps onto the pressure mat sending the authentication data to the Raspberry Pi for processing before it is sent to the server for authentication. Once authentication is complete on the server, a reply will be sent to the client and the client will act accordingly.

\subsection{Communication and Networking}
The pressure mat, USB Hub and electromagnet door lock all get their power from the main outlet while the keypad, camera and fingerprint scanner will be getting their power via the USB connection. The Raspberry Pi also connects to the USB Hub both for power and data transfer between the authentication devices and the client. The client communicates with the server via a LAN cable and the pressure mat and electromagnet door lock connects to the client GPIO pins via I/O cables. 

Once the user steps onto the pressure mat a signal is sent to the client which gets its data from the authentication devices and processes that data before sending it off to the server if it was valid data. The server the authenticates the person and sends the data back to the client that will then, if the authentication was successful, open the door for the user.

\subsection{New Biometric Types}

\subsubsection{Server Side}
Adding a new biometric validator to the system requires source code modification. 
\begin{enumerate}
	\item \textbf{Write the validator} \\
	Each validator should extend the abstract \verb!AccessValidator! class in the \verb!cosbas.biometric.validators! package.	
	\item \textbf{Create a preprocessor} \\ If any processing is required on the biometric data sent to the server before a BioemtricData object is created, a new \verb!BiometricPreprocessor! should also be created. If no preprocessing is required, use the existing \verb!NoProcessing! class
	\item \textbf{Define it as a bean} \\ 
	Declare the validator and preprocessor classes as beans by adding the Spring  \verb!@Component! annotation right before the class definition.
	\item \textbf{Register it on the system} \\
	To register the biometric type on the system add it to the \verb!cosbas.biometric.biometricTypes! enum with its validator and preprocessing class. Eg. 
	\verb!CODE (CodeValidator.class, NoProcessing.class)!. The type should be uppercase.
	
\end{enumerate}

\subsubsection{Client Side}
Adding a new biometric device to the client.
\begin{enumerate}
	\item \textbf{Write the biometric device as a class}
	\\Write a class which will control the biometric device and implements the \verb|Biometric| interface.
	\item \textbf{Define is as a bean}
	\\Declare the class a bean by adding the Spring  \verb!@Component! annotation to it.
	\item \textbf{Register it on the system} \\
	\\To register the biometric device, inject the bean into the Factory class and add the data retrieved from the device to the \verb|ArrayList<BiometricData> data|
\end{enumerate}

\subsection{The Properties File}
\subsubsection{Server Side}
%\item \verb!server.port! The port the server is running on.
%\item \verb!ldap.url! The URL for ldap authentication
ldap.base=ou=Computer Science,o=University of Pretoria,c=ZA
security.basic.enabled=false

mongo.address = 45.55.178.39
mongo.port = 27017
mongo.user = cosbasUser
mongo.password = cosbasPass
mongo.database = COSBAS

codes.newlength = 6

google.clientSecret = vGrU3xTREin5pRTlnAdilARX
google.clientID = 211837377506-qrmd6oco0rsakeelsisd1r4gm8gc5a57.apps.googleusercontent.com

request.pattern.biometric.text=biometric-(.*)(-\\d+)?
request.pattern.biometric.group=1
request.pattern.contact.text=contact-(.*)(-\\d+)?
request.pattern.contact.group=1

faces.certainty=0\.7
faces.classifierFile="faces/haarcascade_frontalface_alt.xml"
faces.imageWidth=200
faces.imageHeight=200

fingers.certainty=50
permissions.newSuper=ALeffley

\subsubsection{Client and Registration}
